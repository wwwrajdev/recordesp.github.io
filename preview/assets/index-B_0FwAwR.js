const f="/fatfs";class l extends Error{constructor(t,e){super(t),this.code=e,this.name="FatFSError"}}async function E(n,t={}){console.info("[fatfs-wasm] createFatFSFromImage() starting");const e=t.wasmURL??new URL(""+new URL("fatfs-ByQyDjoJ.wasm",import.meta.url).href,import.meta.url),s=await y(e),r=U(n),i=t.blockSize??4096;if(i!==4096)throw new Error("blockSize must be 4096");if(t.blockCount&&t.blockCount*i!==r.length)throw new Error("Image size must equal blockSize * blockCount");const o=new Uint8Array(s.memory.buffer),a=s.malloc(r.length||1);if(!a)throw new l("Failed to allocate WebAssembly memory",-3);try{o.set(r,a);const c=s.fatfsjs_init_from_image(a,r.length);if(c<0)throw new l("Failed to initialize FAT16 image",c)}finally{s.free(a)}return console.info("[fatfs-wasm] Filesystem initialized from image"),new p(s)}async function T(n={}){console.info("[fatfs-wasm] createFatFS() starting",n);const t=n.wasmURL??new URL(""+new URL("fatfs-ByQyDjoJ.wasm",import.meta.url).href,import.meta.url),e=await y(t),s=n.blockSize??4096,r=n.blockCount??128;if(s!==4096)throw new Error("blockSize must be 4096");if(!Number.isFinite(r)||r<=0)throw new Error("blockCount must be a positive integer");const i=e.fatfsjs_init(s,r);if(i<0)throw new l("Failed to initialize FatFS",i);if(n.formatOnInit){const o=e.fatfsjs_format();if(o<0)throw new l("Failed to format filesystem",o)}return console.info("[fatfs-wasm] Filesystem initialized"),new p(e)}class p{constructor(t){this.encoder=new TextEncoder,this.decoder=new TextDecoder,this.listBufferSize=4096,this.exports=t,this.heapU8=new Uint8Array(this.exports.memory.buffer)}list(t=f){const e=h(t),s=e,r=this.allocString(e);let i=this.listBufferSize;try{for(;;){const o=this.alloc(i);try{const a=this.exports.fatfsjs_list(r,o,i);if(a===-3){this.listBufferSize=i*2,i=this.listBufferSize;continue}if(this.assertOk(a,"list files"),a===0)return[];const c=this.decoder.decode(this.heapU8.subarray(o,o+a));return b(c).map(m=>({...m,path:g(s,m.path)}))}finally{this.exports.free(o)}}}finally{this.exports.free(r)}}readFile(t){const e=h(t);if(e===f)throw new l("Path must point to a file",-1);const s=this.allocString(e);try{const r=this.exports.fatfsjs_file_size(s);if(this.assertOk(r,`stat file "${e}"`),r===0)return new Uint8Array;const i=this.alloc(r);try{const o=this.exports.fatfsjs_read_file(s,i,r);return this.assertOk(o,`read file "${e}"`),this.heapU8.slice(i,i+r)}finally{this.exports.free(i)}}finally{this.exports.free(s)}}toImage(){const t=this.exports.fatfsjs_storage_size();if(t===0)return new Uint8Array;const e=this.alloc(t);try{const s=this.exports.fatfsjs_export_image(e,t);return this.assertOk(s,"export filesystem image"),this.heapU8.slice(e,e+t)}finally{this.exports.free(e)}}getUsage(){const t=this.exports.fatfsjs_storage_size(),s=this.list(f).reduce((i,o)=>o.type==="file"?i+o.size:i,0),r=t>s?t-s:0;return{capacityBytes:t,usedBytes:s,freeBytes:r}}format(){const t=this.exports.fatfsjs_format();this.assertOk(t,"format filesystem")}writeFile(t,e){const s=h(t);if(s===f)throw new l("Path must point to a file",-1);const r=S(e,this.encoder),i=this.allocString(s),o=r.length?this.alloc(r.length):0;try{r.length>0&&this.heapU8.set(r,o);const a=this.exports.fatfsjs_write_file(i,o,r.length);this.assertOk(a,`write file "${s}"`)}finally{o&&this.exports.free(o),this.exports.free(i)}}deleteFile(t){const e=h(t);if(e===f)throw new l("Path must point to a file",-1);const s=this.allocString(e);try{const r=this.exports.fatfsjs_delete_file(s);this.assertOk(r,`delete file "${e}"`)}finally{this.exports.free(s)}}mkdir(t){const e=h(t);if(e===f)return;const s=this.allocString(e);try{const r=this.exports.fatfsjs_mkdir(s);this.assertOk(r,`mkdir "${e}"`)}finally{this.exports.free(s)}}rename(t,e){const s=h(t),r=h(e),i=this.allocString(s),o=this.allocString(r);try{const a=this.exports.fatfsjs_rename(i,o);this.assertOk(a,`rename "${s}" -> "${r}"`)}finally{this.exports.free(i),this.exports.free(o)}}refreshHeap(){this.heapU8.buffer!==this.exports.memory.buffer&&(this.heapU8=new Uint8Array(this.exports.memory.buffer))}alloc(t){if(t<=0)return 0;const e=this.exports.malloc(t);if(!e)throw new l("Failed to allocate WebAssembly memory",-3);return this.refreshHeap(),e}allocString(t){const e=this.encoder.encode(t),s=this.alloc(e.length+1);return this.heapU8.set(e,s),this.heapU8[s+e.length]=0,s}assertOk(t,e){if(t<0)throw new l(`Unable to ${e}`,t)}}async function y(n){const t=A(n);console.info("[fatfs-wasm] Fetching wasm from",t.href);const e={memory:null},s=x(e);let r=await fetch(t);if(!r.ok)throw new Error(`Unable to fetch FATFS wasm from ${r.url}`);if(console.info("[fatfs-wasm] Fetch complete, status",r.status),"instantiateStreaming"in WebAssembly&&typeof WebAssembly.instantiateStreaming=="function")try{console.info("[fatfs-wasm] Attempting instantiateStreaming");const a=await WebAssembly.instantiateStreaming(r,s);return e.memory=w(a.instance.exports),console.info("[fatfs-wasm] instantiateStreaming succeeded"),a.instance.exports}catch(a){if(console.warn("Unable to instantiate FATFS wasm via streaming, retrying with arrayBuffer()",a),r=await fetch(t),!r.ok)throw new Error(`Unable to fetch FATFS wasm from ${r.url}`);console.info("[fatfs-wasm] Fallback fetch complete, status",r.status)}console.info("[fatfs-wasm] Instantiating from ArrayBuffer fallback");const i=await r.arrayBuffer(),o=await WebAssembly.instantiate(i,s);return e.memory=w(o.instance.exports),console.info("[fatfs-wasm] instantiate(bytes) succeeded"),o.instance.exports}function b(n){return n?n.split(`
`).filter(t=>t.length>0).map(t=>{const[e,s,r]=t.split("	");return{path:e??"",size:Number(s??"0")||0,type:r==="d"?"dir":"file"}}):[]}function h(n){const t=(n??"").trim();if(!t||t==="/")return f;const e=t.replace(/\\/g,"/").replace(/\/{2,}/g,"/"),s=e.endsWith("/")&&e!=="/"?e.slice(0,-1):e;if(s.toLowerCase().startsWith(f)){const i=s.slice(f.length);return i?`${f}${i}`:f}return s.startsWith("/")?`${f}${s}`:`${f}/${s}`}function g(n,t){const e=n.replace(/\/+$/,"");if(!t||t==="/")return e||f;const s=t.replace(/^\/+/,"");return e===f?`${f}/${s}`:`${e}/${s}`}function S(n,t){if(typeof n=="string")return t.encode(n);if(n instanceof Uint8Array)return n;if(n instanceof ArrayBuffer)return new Uint8Array(n);throw new Error("Unsupported file payload type")}function U(n){if(n instanceof Uint8Array)return n;if(n instanceof ArrayBuffer)return new Uint8Array(n);throw new Error("Expected Uint8Array or ArrayBuffer for filesystem image")}function A(n){if(n instanceof URL)return n;const e=(typeof globalThis<"u"&&"location"in globalThis?globalThis.location:void 0)?.href;try{return e?new URL(n,e):new URL(n)}catch(s){throw new Error(`Unable to resolve wasm URL from "${n}": ${String(s)}`)}}function x(n){const t=()=>{},e=()=>0;return{env:{emscripten_notify_memory_growth:t},wasi_snapshot_preview1:{fd_close:e,fd_seek:e,fd_write:(s,r,i,o)=>L(n,s,r,i,o)}}}function L(n,t,e,s,r){const i=n.memory;if(!i)return 0;const o=new DataView(i.buffer);let a=0;for(let c=0;c<s;c++){const m=e+c*8,d=o.getUint32(m,!0),u=o.getUint32(m+4,!0);if(a+=u,t===1||t===2){const F=new Uint8Array(i.buffer,d,u),_=new TextDecoder().decode(F);console.info(`[fatfs-wasm::fd_write fd=${t}] ${_}`)}}return o.setUint32(r,a,!0),0}function w(n){for(const t of Object.values(n))if(t instanceof WebAssembly.Memory)return t;return null}export{f as FAT_MOUNT,l as FatFSError,T as createFatFS,E as createFatFSFromImage};
